#!/usr/bin/env python3
"""
Automated Pico Firmware Builder

Builds firmware for all 4 Pico boards from a single template file.
Only edits firmware_template.c, then run this script to generate all .uf2 files.

Usage:
    python build_all_firmware.py
    
Output:
    pico/firmware_pico0.uf2
    pico/firmware_pico1.uf2
    pico/firmware_pico2.uf2
    pico/firmware_pico3.uf2
"""

import os
import sys
import shutil
import subprocess
from pathlib import Path


# Configuration
SCRIPT_DIR = Path(__file__).parent.absolute()
PICO_DIR = SCRIPT_DIR
TEMPLATE_FILE = PICO_DIR / "firmware_template.c"
CMAKE_TEMPLATE = PICO_DIR / "CMakeLists.txt"
NUM_BOARDS = 4


def print_header(message):
    """Print a formatted header"""
    print(f"\n{'=' * 70}")
    print(f"  {message}")
    print(f"{'=' * 70}\n")


def print_step(step_num, total_steps, message):
    """Print a formatted step"""
    print(f"[{step_num}/{total_steps}] {message}")


def generate_firmware_source(pico_id):
    """Generate firmware .c file for a specific Pico ID"""
    output_file = PICO_DIR / f"firmware_pico{pico_id}.c"
    
    # Read template
    with open(TEMPLATE_FILE, 'r') as f:
        template_content = f.read()
    
    # Replace placeholder with actual Pico ID
    firmware_content = template_content.replace('{{PICO_ID}}', str(pico_id))
    
    # Write output
    with open(output_file, 'w') as f:
        f.write(firmware_content)
    
    print(f"    ✓ Generated: {output_file.name}")
    return output_file


def generate_cmake_file(pico_id):
    """Generate CMakeLists.txt for a specific Pico ID"""
    project_name = f"firmware_pico{pico_id}"
    source_file = f"firmware_pico{pico_id}.c"
    
    cmake_content = f"""# Generated CMake file for Pico {pico_id}
# Auto-generated by build_all_firmware.py

cmake_minimum_required(VERSION 3.13)

set(CMAKE_C_STANDARD 11)
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

# Initialise pico_sdk from installed location
if(WIN32)
    set(USERHOME $ENV{{USERPROFILE}})
else()
    set(USERHOME $ENV{{HOME}})
endif()
set(sdkVersion 2.2.0)
set(toolchainVersion 14_2_Rel1)
set(picotoolVersion 2.2.0-a4)
set(picoVscode ${{USERHOME}}/.pico-sdk/cmake/pico-vscode.cmake)
if (EXISTS ${{picoVscode}})
    include(${{picoVscode}})
endif()

set(PICO_BOARD pico2 CACHE STRING "Board type")

# Pull in Raspberry Pi Pico SDK (must be before project)
include(pico_sdk_import.cmake)

project({project_name} C CXX ASM)

# Initialise the Raspberry Pi Pico SDK
pico_sdk_init()

# Add executable
add_executable({project_name} {source_file})

pico_set_program_name({project_name} "{project_name}")
pico_set_program_version({project_name} "1.0")

# Disable stdio (no USB/UART output needed)
pico_enable_stdio_uart({project_name} 0)
pico_enable_stdio_usb({project_name} 0)

# Link libraries
target_link_libraries({project_name}
        pico_stdlib
        hardware_spi
        hardware_pwm
        hardware_dma)

# Include directories
target_include_directories({project_name} PRIVATE
        ${{CMAKE_CURRENT_LIST_DIR}})

pico_add_extra_outputs({project_name})
"""
    
    output_file = PICO_DIR / "CMakeLists.txt"
    with open(output_file, 'w') as f:
        f.write(cmake_content)
    
    print(f"    ✓ Generated: CMakeLists.txt for Pico {pico_id}")


def build_firmware(pico_id, step_num, total_steps):
    """Build firmware for a specific Pico ID"""
    project_name = f"firmware_pico{pico_id}"
    build_dir = PICO_DIR / "build"
    uf2_source = build_dir / f"{project_name}.uf2"
    uf2_dest = PICO_DIR / f"{project_name}.uf2"
    
    print_step(step_num, total_steps, f"Building firmware for Pico {pico_id}")
    
    # Step 1: Generate source file
    print(f"    Generating source code...")
    generate_firmware_source(pico_id)
    
    # Step 2: Generate CMakeLists.txt
    print(f"    Generating CMakeLists.txt...")
    generate_cmake_file(pico_id)
    
    # Step 3: Create build directory
    print(f"    Setting up build directory...")
    if build_dir.exists():
        shutil.rmtree(build_dir)
    build_dir.mkdir(exist_ok=True)
    
    # Step 4: Run CMake
    print(f"    Running CMake configuration...")
    cmake_result = subprocess.run(
        ["cmake", ".."],
        cwd=build_dir,
        capture_output=True,
        text=True
    )
    
    if cmake_result.returncode != 0:
        print(f"    ✗ CMake failed for Pico {pico_id}")
        print(f"    Error output:")
        print(cmake_result.stderr)
        return False
    
    # Step 5: Run Make
    print(f"    Compiling firmware (this may take a minute)...")
    make_result = subprocess.run(
        ["make", "-j4"],
        cwd=build_dir,
        capture_output=True,
        text=True
    )
    
    if make_result.returncode != 0:
        print(f"    ✗ Build failed for Pico {pico_id}")
        print(f"    Error output:")
        print(make_result.stderr)
        return False
    
    # Step 6: Copy .uf2 file
    if not uf2_source.exists():
        print(f"    ✗ UF2 file not found: {uf2_source}")
        return False
    
    shutil.copy2(uf2_source, uf2_dest)
    print(f"    ✓ Success! Created: {uf2_dest.name}")
    
    # Step 7: Clean up build directory
    print(f"    Cleaning up build directory...")
    shutil.rmtree(build_dir)
    
    # Step 8: Clean up generated source file
    source_file = PICO_DIR / f"firmware_pico{pico_id}.c"
    if source_file.exists():
        source_file.unlink()
        print(f"    Cleaned up: {source_file.name}")
    
    return True


def main():
    """Main build orchestration"""
    print_header("Pico Firmware Builder - Building All Boards")
    
    # Check if template exists
    if not TEMPLATE_FILE.exists():
        print(f"✗ Error: Template file not found: {TEMPLATE_FILE}")
        print(f"  Please ensure firmware_template.c exists in the pico directory.")
        sys.exit(1)
    
    print(f"Template file: {TEMPLATE_FILE.name}")
    print(f"Output directory: {PICO_DIR}")
    print(f"Building firmware for {NUM_BOARDS} Pico boards...\n")
    
    # Build all firmware versions
    total_steps = NUM_BOARDS
    success_count = 0
    failed_boards = []
    
    for pico_id in range(NUM_BOARDS):
        success = build_firmware(pico_id, pico_id + 1, total_steps)
        if success:
            success_count += 1
        else:
            failed_boards.append(pico_id)
    
    # Clean up auto-generated CMakeLists.txt
    cmake_file = PICO_DIR / "CMakeLists.txt"
    if cmake_file.exists():
        cmake_file.unlink()
    
    # Summary
    print_header("Build Summary")
    print(f"✓ Successfully built: {success_count}/{NUM_BOARDS} boards")
    
    if failed_boards:
        print(f"✗ Failed builds: Pico {', '.join(map(str, failed_boards))}")
        sys.exit(1)
    else:
        print(f"\nAll firmware files are ready in: {PICO_DIR}")
        print(f"\nGenerated files:")
        for pico_id in range(NUM_BOARDS):
            uf2_file = PICO_DIR / f"firmware_pico{pico_id}.uf2"
            if uf2_file.exists():
                size_kb = uf2_file.stat().st_size / 1024
                print(f"  • firmware_pico{pico_id}.uf2 ({size_kb:.1f} KB)")
        
        print(f"\n{'=' * 70}")
        print(f"  Next steps:")
        print(f"  1. Connect each Pico board via USB while holding BOOTSEL")
        print(f"  2. Copy the corresponding .uf2 file to the Pico drive")
        print(f"  3. Pico will automatically reboot with new firmware")
        print(f"{'=' * 70}\n")


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\n✗ Build cancelled by user")
        sys.exit(1)
    except Exception as e:
        print(f"\n✗ Unexpected error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
